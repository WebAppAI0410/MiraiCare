name: Workflow Diagnostics

on:
  workflow_dispatch:
    inputs:
      target_workflow:
        description: 'è¨ºæ–­å¯¾è±¡ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - claude.yml
          - auto-error-detection.yml
          - auto-issue-management.yml
          - health-check.yml
  schedule:
    - cron: '0 */6 * * *'  # 6æ™‚é–“ã”ã¨ã«å®Ÿè¡Œ

jobs:
  diagnose:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      actions: read
      pull-requests: read

    steps:
      - uses: actions/checkout@v4

      - name: Comprehensive Workflow Diagnostics
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // è¨ºæ–­å¯¾è±¡ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
            const workflows = [
              { name: 'claude.yml', displayName: 'Claude Code Actions' },
              { name: 'auto-error-detection.yml', displayName: 'Auto Error Detection' },
              { name: 'auto-issue-management.yml', displayName: 'Auto Issue Management' },
              { name: 'health-check.yml', displayName: 'Project Health Check' },
              { name: 'workflow-monitor.yml', displayName: 'Workflow Monitor' }
            ];
            
            let diagnosticReport = {
              summary: { total: 0, working: 0, issues: 0 },
              details: [],
              recommendations: []
            };
            
            for (const workflow of workflows) {
              diagnosticReport.summary.total++;
              
              try {
                // ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œå±¥æ­´ã‚’å–å¾—
                const runs = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow.name,
                  per_page: 10
                });
                
                const recentRuns = runs.data.workflow_runs.slice(0, 5);
                const successCount = recentRuns.filter(run => run.conclusion === 'success').length;
                const failureCount = recentRuns.filter(run => run.conclusion === 'failure').length;
                const totalRuns = recentRuns.length;
                
                let status = 'âœ… æ­£å¸¸';
                let issues = [];
                
                // è¨ºæ–­ãƒ­ã‚¸ãƒƒã‚¯
                if (totalRuns === 0) {
                  status = 'âŒ æœªå®Ÿè¡Œ';
                  issues.push('ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãŒä¸€åº¦ã‚‚å®Ÿè¡Œã•ã‚Œã¦ã„ã¾ã›ã‚“');
                  diagnosticReport.summary.issues++;
                } else if (failureCount / totalRuns > 0.5) {
                  status = 'ğŸ”´ é«˜å¤±æ•—ç‡';
                  issues.push(`å¤±æ•—ç‡ãŒé«˜ã™ãã¾ã™ (${Math.round(failureCount/totalRuns*100)}%)`);
                  diagnosticReport.summary.issues++;
                } else if (failureCount > 0) {
                  status = 'ğŸŸ¡ éƒ¨åˆ†çš„å•é¡Œ';
                  issues.push(`æœ€è¿‘ã®å®Ÿè¡Œã§${failureCount}å›å¤±æ•—ã—ã¦ã„ã¾ã™`);
                } else {
                  diagnosticReport.summary.working++;
                }
                
                // ç‰¹å®šãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®è©³ç´°è¨ºæ–­
                if (workflow.name === 'claude.yml') {
                  // Claude Code Actionsç‰¹æœ‰ã®è¨ºæ–­
                  if (totalRuns === 0) {
                    issues.push('GitHub Appè¨­å®šãŒä¸å®Œå…¨ãªå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™');
                    issues.push('CLAUDE_APP_ID/CLAUDE_PRIVATE_KEYã®è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„');
                  }
                  
                  // @claudeãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹Issueã‚’ãƒã‚§ãƒƒã‚¯
                  const claudeIssues = await github.rest.issues.listForRepo({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    state: 'open',
                    per_page: 10
                  });
                  
                  const mentionedIssues = claudeIssues.data.filter(issue => 
                    issue.body && issue.body.includes('@claude')
                  );
                  
                  if (mentionedIssues.length > 0 && totalRuns === 0) {
                    issues.push(`@claudeãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹${mentionedIssues.length}å€‹ã®Issueã«å¿œç­”ã—ã¦ã„ã¾ã›ã‚“`);
                  }
                }
                
                diagnosticReport.details.push({
                  workflow: workflow.displayName,
                  file: workflow.name,
                  status: status,
                  runs: totalRuns,
                  success: successCount,
                  failure: failureCount,
                  issues: issues,
                  lastRun: totalRuns > 0 ? recentRuns[0].created_at : 'ãªã—'
                });
                
              } catch (error) {
                diagnosticReport.summary.issues++;
                diagnosticReport.details.push({
                  workflow: workflow.displayName,
                  file: workflow.name,
                  status: 'âŒ ã‚¨ãƒ©ãƒ¼',
                  runs: 0,
                  success: 0,
                  failure: 0,
                  issues: [`è¨ºæ–­ã‚¨ãƒ©ãƒ¼: ${error.message}`],
                  lastRun: 'ãªã—'
                });
              }
            }
            
            // æ¨å¥¨äº‹é …ã®ç”Ÿæˆ
            if (diagnosticReport.summary.issues > 0) {
              diagnosticReport.recommendations.push('å¤±æ•—ã—ã¦ã„ã‚‹ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®è©³ç´°ãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„');
              diagnosticReport.recommendations.push('GitHub Secretsã®è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„');
              diagnosticReport.recommendations.push('ä¾å­˜é–¢ä¿‚ã¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„');
            }
            
            // Repository Secretsã®ç¢ºèªï¼ˆå¯èƒ½ãªç¯„å›²ã§ï¼‰
            try {
              const secrets = await github.rest.actions.listRepoSecrets({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              
              const requiredSecrets = ['ANTHROPIC_API_KEY'];
              const missingSecrets = requiredSecrets.filter(secret => 
                !secrets.data.secrets.some(s => s.name === secret)
              );
              
              if (missingSecrets.length > 0) {
                diagnosticReport.recommendations.push(`ä¸è¶³ã—ã¦ã„ã‚‹Secrets: ${missingSecrets.join(', ')}`);
              }
              
            } catch (error) {
              console.log('Secretsç¢ºèªã‚’ã‚¹ã‚­ãƒƒãƒ—:', error.message);
            }
            
            // ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
            const reportBody = `## ğŸ” ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆ

            ### ğŸ“Š æ¦‚è¦
            - **ç·ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼æ•°**: ${diagnosticReport.summary.total}
            - **æ­£å¸¸å‹•ä½œ**: ${diagnosticReport.summary.working}
            - **å•é¡Œã‚ã‚Š**: ${diagnosticReport.summary.issues}
            - **å¥å…¨æ€§ã‚¹ã‚³ã‚¢**: ${Math.round((diagnosticReport.summary.working / diagnosticReport.summary.total) * 100)}%

            ### ğŸ“‹ è©³ç´°è¨ºæ–­çµæœ

            ${diagnosticReport.details.map(detail => `
            #### ${detail.status} ${detail.workflow}
            - **ãƒ•ã‚¡ã‚¤ãƒ«**: \`${detail.file}\`
            - **å®Ÿè¡Œå›æ•°**: ${detail.runs}å› (æˆåŠŸ: ${detail.success}, å¤±æ•—: ${detail.failure})
            - **æœ€çµ‚å®Ÿè¡Œ**: ${detail.lastRun}
            ${detail.issues.length > 0 ? `- **å•é¡Œ**: ${detail.issues.map(issue => `\n  - ${issue}`).join('')}` : ''}
            `).join('\n')}

            ### ğŸ”§ æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
            ${diagnosticReport.recommendations.map(rec => `- [ ] ${rec}`).join('\n')}

            ### ğŸ“ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
            1. å¤±æ•—ã—ã¦ã„ã‚‹ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®è©³ç´°ãƒ­ã‚°ã‚’ç¢ºèª
            2. å¿…è¦ãªSecretsãƒ»è¨­å®šã®è¿½åŠ 
            3. ä¾å­˜é–¢ä¿‚ã®ä¿®æ­£
            4. å†ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

            ---
            *è¨ºæ–­å®Ÿè¡Œæ™‚åˆ»: ${new Date().toISOString()}*
            `;
            
            console.log('=== ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼è¨ºæ–­çµæœ ===');
            console.log(`å¥å…¨æ€§ã‚¹ã‚³ã‚¢: ${Math.round((diagnosticReport.summary.working / diagnosticReport.summary.total) * 100)}%`);
            console.log(`æ­£å¸¸: ${diagnosticReport.summary.working}, å•é¡Œ: ${diagnosticReport.summary.issues}`);
            
            // å•é¡ŒãŒã‚ã‚‹å ´åˆã¯Issueã‚’ä½œæˆ
            if (diagnosticReport.summary.issues > 0) {
              const existingIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: 'workflow-diagnostics',
                state: 'open'
              });
              
              const today = new Date().toISOString().split('T')[0];
              const existingToday = existingIssues.data.find(issue => 
                issue.title.includes('ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼è¨ºæ–­') && 
                issue.title.includes(today)
              );
              
              if (!existingToday) {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `[è¨ºæ–­] ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆ - ${today}`,
                  body: reportBody,
                  labels: ['workflow-diagnostics', 'needs-fix']
                });
                
                console.log('è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆIssueã‚’ä½œæˆã—ã¾ã—ãŸ');
              }
            }

      - name: Update workflow status documentation
        uses: actions/github-script@v7
        with:
          script: |
            // doc/workflow-status.mdã‚’è‡ªå‹•æ›´æ–°
            const fs = require('fs');
            const path = 'doc/workflow-status.md';
            
            try {
              let content = fs.readFileSync(path, 'utf8');
              
              // æœ€çµ‚æ›´æ–°æ™‚åˆ»ã‚’æ›´æ–°
              const now = new Date().toISOString();
              content = content.replace(
                /\*æœ€çµ‚æ›´æ–°: .*\*/,
                `*æœ€çµ‚æ›´æ–°: ${now}*`
              );
              
              fs.writeFileSync(path, content);
              console.log('ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼çŠ¶æ³ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’æ›´æ–°ã—ã¾ã—ãŸ');
              
            } catch (error) {
              console.log('ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ã‚’ã‚¹ã‚­ãƒƒãƒ—:', error.message);
            } 